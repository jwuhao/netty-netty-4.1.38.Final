package io.netty.actual.combat.e1;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class Test1 {


    public static void main(String[] args) throws Exception {

        ServerSocket serverSocket = new ServerSocket(8080);
        // ServerSocket 上的accept()方法将会一直阻塞到一个连接建立，随后返回一个新的Socket 用于客户端和服务器之间的通信， 该ServerSocket
        Socket clientSocket = serverSocket.accept();  //  对accept()方法的调用将被阻塞，直到一个连接建立
        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        // BufferedReader和PrintWriter 都衍生自Socket的输入输出流， 前者从一个字符输入流中读取文本，后者打印对象的格式化的表示到文本输出流
        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); // 这些流对象都派生于该套接字的流对象
        String request = "";
        String response = "";
        while ((request = in.readLine()) != null) { // readLine()方法将阻塞，直到在一个由换行符或者回车符结尾的字符串被读取 。
            if ("Done".equals(request)) {
                break;
            }
            //response = proceRequest(request);             // 请求被传递给服务器的处理方法
            out.println(response); // 继续执行循环处理
        }

        // 这段代码片段将只能现时处理一个连接，要管理多个并发客户端，需要为每个新的客户端Socket创建一个新的Thread , 让我们考虑一下这种方案
        // 的影响 ， 第一，在任何时候都可能有大量的线程处于休眠状态，只是在等待输入或者输出数据就绪，这可能算是一种资源浪费，第二，需要
        // 为每个线程调用栈都分配内存，其默认值大小区间为64KB么1MB, 具体取决于操作系统，第三，即使Java 虚拟机（JVM ）在物理上可以支持非
        // 常大数量的线程，但是远在达到极限之前，上下文切换所带来的开销就会带来麻烦 ， 例如，在达到 10 000 个连接的时候。
        // 虽然这种并发方案对于支撑中小数量的客户端来说还算是可以接受的， 但是为了支撑100 000 或 者更多的并发连接所需要的资源使得它很不理想 。
        // 幸运的是， 还有一种方案。


        // Java NIO
        // 除了代码清单1.1 中代码底层的阻塞系统调用外，本地套接字库很早就提供了非阻塞调用，其为网络资源的利用率提供了相当多的控制 。
        // 可以使用setsockopt() 方法配置套接字，以便读/写调用在没有数据时候立即返回，也就是说，如果一个阻塞调用应该已经被阻塞了。
        // 可以使用操作系统的事件通知API 注册一组非阻塞套接字，以便确定他们是否有任何套接字已经数据可推供读写。
        // Java 对于非阻塞I/O的支持是在2002年引入的， 位于 JDK 1.4 的java.nio包中。
        // 新的还是非阻塞的
        // NIO 最开始的时候是输入/输出（New Input/Output）的英文缩写，但是，该Java API已经出现足够长的时间也，不再是新的了，因此
        // ,如果大多数的用户认为NIO代表非阻塞 I/O（Non-blocking I/O），而阻塞I/O(blocking I/O)是旧的输入/输出（old input/output ,OIO）
        // 你也可能遇到它被称为普通的I/O(plain I/O)的时候 。
        // 选择器
        // 展示了一个非阻塞设计，其实际上消除了上一节中所描述的那些弊端，
        // class java.nio.channels.Selector是java 的非阻塞I/O实现的关键，它使用了事件通知API 以确定在一组非阻塞套接字中有哪些已经就绪，
        // 能够进行I/O相关的操作，因此可以在任何时间检查任意的读操作或者写操作的完成状态，所以如图1-2所示，一个单一的线程便可以处理多个并发的连接 。
        // 总体来看，与阻塞I/O模型相比，这种模型提供了更好的资源管理 。
        // 使用较少的线程便可以处理许多的连接，因此也减少了内存管理和上下文切换所带来的开销，
        // 当没有I/O操作需要处理的时候，线程也可以被用于其他任务 。
        // 尽管已经有许多直接使用Java NIO API 的应用程序被构建了，但是要做到如此正确和安全并不容易，特别是，在高负责下可靠和高效的
        // 处理和调试I/O操作是一项繁琐而且容易出错的任务，最好留给高性能的网络编程专家-Netty .


        // 不久以前， 我们本端开开始呈现的场景-支持成千上万的并发客户端，还被认为是不可能的， 然而今天，作为系统用户，我们将这种能力视为
        // 理所当然，同时作为开发人员，我们期望将水平钱提高得更高， 因为我们知道，总会有更高的吞吐量和可扩展性的要求 ，在更低的成本的基础上
        // 进行交付。
        // 不要低估了这最后一点的重要性， 我们已经从漫长的痛苦经历中尝到，直到使用底层的API暴露了复杂性， 并且引入了对往往供不求的技能关键
        // 性依赖， 这也就是，面向对象的基本概念，用较简单的抽象隐藏底层实现的复杂性。
        // 这一原则也催生了大量的框架开发，它们为常见的编程任务封装了解决方案，其中许多的都和分页式系统的开发密切相关，我们可以确定
        // 的说，所有专业的Java 开发人员都至少对它们熟知一二，

        // 在日常生活中，异步自然而然的就发生了， 所以你可能没有对它考虑多少，但是让一个计算机程序以相同的方式工作就会产生一些非常特殊的问题
        // 本质上，国一个既是异步又是事件的驱动系统会表现出一种特殊，对我们来说极具价值的行为，它可以以任意的顺序在任意的时间点产生的事件 。
        //

        // NIO
        // 在内核数据没有准备好的阶段，用户线程发起了IO请求时，立即返回，所以，为了读取到最终的数据，用户线程需要不断的发起IO 系统调用 。
        // 2. 内核数据到达后，用户线程发起的系统调用，用户线程阻塞，内核开始复制数据，它将数据从内核缓冲区复制到用户缓冲区， （用户空间的内存）
        // ,然后内核返回结果（例如返回复制的用户缓冲区的字节数）
        // 3 用户线程读取到数据后，才会解除阻塞状态，重新运行起来，也就是说，用户进程需要经过多次尝试，才能保证最终真正的读取到数据，而后
        // 继续执行。

        // 如何避免同步非阻塞IO模型中轮询等待问题呢？ 这就是IO多路复用模型 。
        // 在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态，在Linux系统中，对应的系统调用为select/epoll系统调用，通过该
        // 系统调用，一个进程可以监视多个文件描述符，一旦某个文件描述符就绪，一般是内核缓冲区可读/可写， 内核能够将就绪状态返回给应用
        // 应用程序，
        // 举个例子， 发起一个异步IO的read读操作系统调用，流程如下 ：
        // 1. 当用户线程发起了了个read系统调用，立刻就可以开始去做其他事情，用户线程不阻塞 。
        // 2. 内核就开始了IO的第一阶段，准备数据，等到数据准备好了， 内核就会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存）
        // 3. 内核会给用户线程发送一个信号（Signal），或者回调用户注册的回调接口，告诉用户线程read操作完成了。
        // 4. 用户线程读取用户缓冲区的数据，完成后续业务操作。
        // 异步IO模型的特点，在内核等待数据和复制数据两个阶段，用户线程都不是阻塞的，  用户线程需要接收内核的IO操作完成的事件，或者用户线程
        // 需要注册一个IO操作完成的回调函数，正因为如此，异步IO有的时候也被称为信号驱动IO
        // 异步IO异步模型的缺点，应用程序仅需要进行事件的注册也接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。
        // 理论上来说，异步IO是真正的异步输入输出，它的吞吐量高于 IO 多路利用模型的吞吐量，模型在2.6版本才引入，目前并不完善，其底层
        // 实现仍然使用了epol，与IO多嘴利用的相同，因此在性能上没有明显的优势 。
        // 大多数高并必服务器程序，一般都是基于Linux系统的， 因而，目前这类高并发网络应用程序开发，大多数采用的是IO多路复用模型 。
        // 是高并发IO的底层原理，前面已经深入浅出介绍了高并发IO的模型，但是，即使采用了最先进的模型，如果不进行合理的配置，也没有办法
        // 支撑百万级的网络并发，这里所涉及的配置，就是Linux操作系统中文件句柄的数量限制 。
        // 顺便说下， 在生产环境中，大家都使用Linux 系统，所以，后续文字中假想生产操作系统都是Linux 系统，另外，由于大多数同学使用了
        // Windows 进行学习和工作，因此，后续文字中假想的开发所用的操作系统是windows系统 。
        // 在生产环境Linux系统中，基本上都需要解任文件句柄数的限制，原因，Linux 系统的默认值是1024，也就是说，一个进程最多可以接受1024
        // 个socket连接，这是远远不够的。
        // 文件句柄，也叫文件描述符，在Linux 系统中，文件可分为，普通文件，目录文件，链接文件和设备文件，文件描述符（File Descriptor）
        // 是内核为了高效管理已经被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件，所有的IO系统调用
        // 包括socket的读写调用，都是通过文件描述符完成的。
        // 在Linux 下，通过调用ulimit命令，可以看到单个进程能够打印的最大文件句柄数量，这个命令的具体使用方法是：
        // ulimit -n
        // 什么是ulimit命令呢？ 它是用来显示和修改当前用户进程的一些基础限制的命令，-n 命令选项用于引用或设置当前的文件句柄数量的限制值
        // Linux 的系统默认值为1024
        // 默认的数值是1024，对绝大多数应用（例如 Apache , 桌面应用程序）来说已经足够了，但是，是对于一些用户期数很大的高并发应用，则
        // 是远远不够的，一个高并发的应用，面临的并发连接数往往是十万级，百万级，千万组，甚至像腾讯 QQ 一样的上亿级。
        // 文件句柄数不够，会导致什么样的后果呢？ 当单个进程打印的文件句柄数量，超过了系统配置的上限时，就会发出"socket/file:Can nto open so many files" 的错误提示
        // 对于 高并发，高负载的应用，就必须要调整这个系统参数，以适应处理并发处理大量连接的应用场景，可以通过ulimit来设置这两个参数，该当如下 ：
        // ulimit -n 10000
        // 在上面的命令中，n 的设置值越大， 可以打开的文件句柄数量就越大，建议使用root用户来执行些命令。
        // 如果想永久的把设置值保存下来， 可以编辑/etc/rc.local开机启动文件，在文件中添加如下内容：
        // ulimit -SHn 1000000
        // 增加-S和-H两个命令选项，选项-S表示软性极限值，-H 表示硬性极限值， 硬性极限的实际限制就是最大可以是100万，不能再多了。
        // 软性极限是系统警告Warning的超过这个极限值，内核会发出警告。
        // 普通用户通过ulimit命令，可以将软极限更改到硬极限的最大设置值，如果要更改硬极限，必须拥有root用户权限 。
        // 终极解除Linux 系统的最大文件打开数量的限制，可以通过编辑Linux 的极限配置文件/etc/security/limits.conf 来解决这些问题，修改文件，加入如下内容
        // soft nofile 100 0000
        // hard nofile 100 0000
        // 高性能的Java通信，
        // 1.4版本之前，JavaIO 类库是阻塞IO  从，1.4版本开始，引进了新的异步IO 库，被称为Java New IO类库， 简称为JAVA NIO 为了非阻塞IO
        // （Non-Block IO） 称为老式的阻塞式Java IO 为OIO ,总体来说，NIO 弥补了原来面向流OIO同步阻塞的不足，它为标准的Java 代码rjwqb调整面向缓冲区的IO
        // Java NIO由以下三个核心组件组成
        // Channel 通道
        // Buffer 缓冲区
        // Selector 选择器。
        // 如果理解了第1章的四种IO模型，大家一眼就认识出来，JavaNIO 属于第三种模型 ，IO 多路利用模型，当然，JavaNIO 组件，提供了统一的API,为
        // 大家一眼就能认出来底层的不同操作系统之间的差异 。 后面的章节，我们会对以上的三种JavaNIO 核心组件，展开详细的介绍，先来看看java 的NIO 和OIO 简单对比 。
        // NIO和OIO的对比
        // 1. OIO是面向流（Stream Oriented）的，NIO是面向缓冲区的， （Buffer Oriented）的
        // 何谓面向流，何谓面向缓冲区 呢？
        // OIO是面向字节流或字符流 ， 在一般的OIO操作中，我们以流式的方式顺序地人一个（Stream）中读取一个或多个字节，因此，我们不能随意的改变读取指针的
        // 位置，而在NIO操作中则不同，NIO 中引入了Channel 通道，和Buffer(缓冲区)的概念，读取和写入只需要从组阁中读取数据到缓冲区中
        // 或将数据从缓冲区中写入到通道中，NIO 不旬OIO那样是顺序的操作，可以随意的读取Buffer中任意位置的数据 。
        // 通道 Channel
        // 在OIO 中，同一个网络连接会关联到两个流， 一个输入流（Input Stream） ，另外一个输出流（Output Stream） ，通过这两个流，不断的进行输入和输出操作
        // 在NIO 中，同一个网络连接使用一个通道表示，所有的NIO的IO操作都是从通道开始的 ，一个通道类似于OIO中两个流的结合体，既可以从
        // 通道读取，也可以向通道中写入。
        // Selector 选择器
        // 首先，回顾一个基础的问题，什么是IO多路利用，指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来）
        // 表示，一旦其中一个或多个文件搭售符可读或可写，系统内核就通知该进程/线程， 在Java 应用层面，如何实现对多个文件描述符的监视呢？
        // 需要用到一个非常重要的Java NIO组件，Selector 选择器。
        // 选择器的神奇功能是什么呢？它是一个IO事件的查询器，通过选择器，一个线程可能查询多个通道的IO事件的就绪状态
        // 实现IO多路复用，从具体的开发层面来说，首先把通道注册到选择器中， 然后通过选择器的内部机制，可以查询（select）这些注册的通道是否已经有就绪的IO事件 。
        // 例如可读，可写，网络连接完成等。
        // 一个选择器需要一个线程进行监控，换句话说，我们可以很简单的使用一个线程，通过选择器去管理多个通道，这是非常高效的， 这种高效来
        // 自于Java 的选择器组合Selector ，以及背后的操作系统底层的IO多路利用的支持。
        // 与OIO相比，使用选择器的最大优势，系统开销小， 系统不必为每一个网络连接（文件描述符创建进程或线程）从而大大减少了系统的开销。
        // 缓冲区（Buffer）
       // 应用程序与通道（Channel）主要的交互操作，就是进行数据的read读取和write写入，为了完成如此大任，NIO为大家准备了第三个重要的组件
        // -NIO Buffer （NIO 缓冲区） 通道的读取就是将数据从通道读取到缓冲区中， 通道的写入就是将数据从缓冲区写入到通道中。
        // 缓冲区的使用，里面向流的OIO所没有的， 也就是NIO非阻塞的重要前提和基础之一 。
        // 下面从缓冲区开始，详细介绍了NIO的Buffer(缓冲区)Channel(通道)Selector(选择器)三大核心组件。
        // 3.2 详解NIO Buffer类及其属性
        // NIO的Buffer（缓冲区）本质上是一个内存块， 既可以写入数据，也可以从中读取数据，NIO的Buffer类是一个抽象类，位于java.nio包中
        // 其内部是一个内存块
        // NIO的Buffer与普通的内存块（Java 数组）不同的是：NIO Buffer对象，提供了一组更加有效的方法，用来进行写入和读取的交替访问
        // 需要强调的是：Buffer类是一个非线程安全类。
        // Buffer类
        // Buffer类是一个抽象类， 对应于Java的主要数据类型，在NIO中有8种缓冲区类， 分别如下ByteBuffer,CharBuffer,DoubleBuffer, FloatBuffer
        // IntBuffer , LongBuffer,ShortBuffer , MappedByteBuffer
        // 前7种Buffer类型，覆盖了能在IO中的传输的所有的Java 基本数据类型，第8种类型MappeedByteBuffer是专门用于内存映射的一种ByteBuffer类型
        // 实际上，使用最多的还是ByteBuffer二进制字节缓冲区类型，后面会看到 。
        // Buffer类在其内部，有一个byte[]类数组内存块， 作为内存缓冲区，为了记录读写的状态和位置Buffer类提供了一些重要的属性，其中有3个重要的成员属性
        // capacity(容量)，position(读写位置)，limit读写限制 。
        // 除此之外，还有一个标记属性，mark标记，可以将当前的position的临时存入到mark中，需要的时候，可以再从mark标记中恢复到position的位置 。
        // 1. capacity属性
        // Buffer类的capacity属性，表示内存容量的大小，一旦写入的对象数量超过了capacity容量缓冲区就满了，不能再写入了。
        // Buffer类的capacity属性一旦初始化，就不能再改变，原因是什么呢？ Buffer类的对象在初始化时，会按照capacity分配内部内存，在内存分配好之后 。
        // 它的大小当然就不能被改变了。
        // 再强调一下，capacity容量不是指内存块byte[]数组的字节的数量，capacity容量指的是写入数据对象的数量 。
        // 前面讲到的，Buffer类是一个抽象类，Java不能直接用来新建对象，使用的时候，必须使用Buffer的某个子类，例如使用DoubleBuffer
        // 一则是写入的数据是double类型，如果其capacity是100,那我们最多可以写入100个double数据 。
        // 2. position属性
        // Buffer类的position属性，表示当前的位置，position属性与缓冲区的读写模式有关，在不同的模式下，position属性的值是不同的。
        // 当缓冲区进行读写的模式改变时，position会进行调整。
        // 在写模式下，position的值变化规则如下：1. 在刚刚进入到写模式时，position的值为0，表示当前的写入位置为从头开始，2.每当一个
        // 数据写到缓冲区之后，position会向后移动到下一个可写的位置 ， 3. 初始化postion的值为0 ， 最大可写入的值为limit-1 ,当position
        // 的值达到limit时，缓冲区就已经无空间可写。
        // 在读模式下，position的值变化规则如下 ：1.当缓冲区刚开始进入读模式时，position会被重置为0，当从缓冲区读取时，也是从postion位置开始读
        // 读取数据后，position向前移动到下下个可读的位置 ， 3. position最大值为最大可读上限limit，当position达到 limit时，表明缓冲区已经无数据可读。
        // 起点在哪里呢？当新建一个缓冲区时， 缓冲区处于写入模式，这时可以写数据，数据写入后，如果要从缓冲区读取数据，这就要进行模式的切换
        // 可以使用即调用flip 翻转方法，将缓冲区变成读取模式 。
        // 在这个flip翻转过程上，position会进行非常巨大的调整，可以使用即调用flip翻转方法,也就是0，表示可以从开头开始读，flip翻转的另外
        // 一半的工作，就是要调整limit属性
        // limit 属性
        // Buffer类的limit属性，表示读写的最大上限，limit属性，也与缓冲区的读写模式有关，在不同的模式下，limit的含义不相同的。
        //




    }
}
