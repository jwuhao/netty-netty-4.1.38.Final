package io.netty.actual.combat.e1;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class Test1 {


    public static void main(String[] args) throws Exception {

        ServerSocket serverSocket = new ServerSocket(8080);
        // ServerSocket 上的accept()方法将会一直阻塞到一个连接建立，随后返回一个新的Socket 用于客户端和服务器之间的通信， 该ServerSocket
        Socket clientSocket = serverSocket.accept();  //  对accept()方法的调用将被阻塞，直到一个连接建立
        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        // BufferedReader和PrintWriter 都衍生自Socket的输入输出流， 前者从一个字符输入流中读取文本，后者打印对象的格式化的表示到文本输出流
        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); // 这些流对象都派生于该套接字的流对象
        String request = "";
        String response = "";
        while ((request = in.readLine()) != null) { // readLine()方法将阻塞，直到在一个由换行符或者回车符结尾的字符串被读取 。
            if ("Done".equals(request)) {
                break;
            }
            //response = proceRequest(request);             // 请求被传递给服务器的处理方法
            out.println(response); // 继续执行循环处理
        }

        // 这段代码片段将只能现时处理一个连接，要管理多个并发客户端，需要为每个新的客户端Socket创建一个新的Thread , 让我们考虑一下这种方案
        // 的影响 ， 第一，在任何时候都可能有大量的线程处于休眠状态，只是在等待输入或者输出数据就绪，这可能算是一种资源浪费，第二，需要
        // 为每个线程调用栈都分配内存，其默认值大小区间为64KB么1MB, 具体取决于操作系统，第三，即使Java 虚拟机（JVM ）在物理上可以支持非
        // 常大数量的线程，但是远在达到极限之前，上下文切换所带来的开销就会带来麻烦 ， 例如，在达到 10 000 个连接的时候。
        // 虽然这种并发方案对于支撑中小数量的客户端来说还算是可以接受的， 但是为了支撑100 000 或 者更多的并发连接所需要的资源使得它很不理想 。
        // 幸运的是， 还有一种方案。


        // Java NIO
        // 除了代码清单1.1 中代码底层的阻塞系统调用外，本地套接字库很早就提供了非阻塞调用，其为网络资源的利用率提供了相当多的控制 。
        // 可以使用setsockopt() 方法配置套接字，以便读/写调用在没有数据时候立即返回，也就是说，如果一个阻塞调用应该已经被阻塞了。
        // 可以使用操作系统的事件通知API 注册一组非阻塞套接字，以便确定他们是否有任何套接字已经数据可推供读写。
        // Java 对于非阻塞I/O的支持是在2002年引入的， 位于 JDK 1.4 的java.nio包中。
        // 新的还是非阻塞的
        // NIO 最开始的时候是输入/输出（New Input/Output）的英文缩写，但是，该Java API已经出现足够长的时间也，不再是新的了，因此
        // ,如果大多数的用户认为NIO代表非阻塞 I/O（Non-blocking I/O），而阻塞I/O(blocking I/O)是旧的输入/输出（old input/output ,OIO）
        // 你也可能遇到它被称为普通的I/O(plain I/O)的时候 。
        // 选择器
        // 展示了一个非阻塞设计，其实际上消除了上一节中所描述的那些弊端，
        // class java.nio.channels.Selector是java 的非阻塞I/O实现的关键，它使用了事件通知API 以确定在一组非阻塞套接字中有哪些已经就绪，
        // 能够进行I/O相关的操作，因此可以在任何时间检查任意的读操作或者写操作的完成状态，所以如图1-2所示，一个单一的线程便可以处理多个并发的连接 。
        // 总体来看，与阻塞I/O模型相比，这种模型提供了更好的资源管理 。
        // 使用较少的线程便可以处理许多的连接，因此也减少了内存管理和上下文切换所带来的开销，
        // 当没有I/O操作需要处理的时候，线程也可以被用于其他任务 。
        // 尽管已经有许多直接使用Java NIO API 的应用程序被构建了，但是要做到如此正确和安全并不容易，特别是，在高负责下可靠和高效的
        // 处理和调试I/O操作是一项繁琐而且容易出错的任务，最好留给高性能的网络编程专家-Netty .


        // 不久以前， 我们本端开开始呈现的场景-支持成千上万的并发客户端，还被认为是不可能的， 然而今天，作为系统用户，我们将这种能力视为
        // 理所当然，同时作为开发人员，我们期望将水平钱提高得更高， 因为我们知道，总会有更高的吞吐量和可扩展性的要求 ，在更低的成本的基础上
        // 进行交付。
        // 不要低估了这最后一点的重要性， 我们已经从漫长的痛苦经历中尝到，直到使用底层的API暴露了复杂性， 并且引入了对往往供不求的技能关键
        // 性依赖， 这也就是，面向对象的基本概念，用较简单的抽象隐藏底层实现的复杂性。
        // 这一原则也催生了大量的框架开发，它们为常见的编程任务封装了解决方案，其中许多的都和分页式系统的开发密切相关，我们可以确定
        // 的说，所有专业的Java 开发人员都至少对它们熟知一二，

        // 在日常生活中，异步自然而然的就发生了， 所以你可能没有对它考虑多少，但是让一个计算机程序以相同的方式工作就会产生一些非常特殊的问题
        // 本质上，国一个既是异步又是事件的驱动系统会表现出一种特殊，对我们来说极具价值的行为，它可以以任意的顺序在任意的时间点产生的事件 。
        //

        // NIO
        // 在内核数据没有准备好的阶段，用户线程发起了IO请求时，立即返回，所以，为了读取到最终的数据，用户线程需要不断的发起IO 系统调用 。
        // 2. 内核数据到达后，用户线程发起的系统调用，用户线程阻塞，内核开始复制数据，它将数据从内核缓冲区复制到用户缓冲区， （用户空间的内存）
        // ,然后内核返回结果（例如返回复制的用户缓冲区的字节数）
        // 3 用户线程读取到数据后，才会解除阻塞状态，重新运行起来，也就是说，用户进程需要经过多次尝试，才能保证最终真正的读取到数据，而后
        // 继续执行。

        // 如何避免同步非阻塞IO模型中轮询等待问题呢？ 这就是IO多路复用模型 。
        // 在IO多路复用模型中，引入了一种新的系统调用，查询IO的就绪状态，在Linux系统中，对应的系统调用为select/epoll系统调用，通过该
        // 系统调用，一个进程可以监视多个文件描述符，一旦某个文件描述符就绪，一般是内核缓冲区可读/可写， 内核能够将就绪状态返回给应用
        // 应用程序，
        // 举个例子， 发起一个异步IO的read读操作系统调用，流程如下 ：
        // 1. 当用户线程发起了了个read系统调用，立刻就可以开始去做其他事情，用户线程不阻塞 。
        // 2. 内核就开始了IO的第一阶段，准备数据，等到数据准备好了， 内核就会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存）
        // 3. 内核会给用户线程发送一个信号（Signal），或者回调用户注册的回调接口，告诉用户线程read操作完成了。
        // 4. 用户线程读取用户缓冲区的数据，完成后续业务操作。
        // 异步IO模型的特点，在内核等待数据和复制数据两个阶段，用户线程都不是阻塞的，  用户线程需要接收内核的IO操作完成的事件，或者用户线程
        // 需要注册一个IO操作完成的回调函数，正因为如此，异步IO有的时候也被称为信号驱动IO
        // 异步IO异步模型的缺点，应用程序仅需要进行事件的注册也接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。
        // 理论上来说，异步IO是真正的异步输入输出，它的吞吐量高于 IO 多路利用模型的吞吐量，模型在2.6版本才引入，目前并不完善，其底层
        // 实现仍然使用了epol，与IO多嘴利用的相同，因此在性能上没有明显的优势 。
        // 大多数高并必服务器程序，一般都是基于Linux系统的， 因而，目前这类高并发网络应用程序开发，大多数采用的是IO多路复用模型 。
        // 是高并发IO的底层原理，前面已经深入浅出介绍了高并发IO的模型，但是，即使采用了最先进的模型，如果不进行合理的配置，也没有办法
        // 支撑百万级的网络并发，这里所涉及的配置，就是Linux操作系统中文件句柄的数量限制 。
        // 顺便说下， 在生产环境中，大家都使用Linux 系统，所以，后续文字中假想生产操作系统都是Linux 系统，另外，由于大多数同学使用了
        // Windows 进行学习和工作，因此，后续文字中假想的开发所用的操作系统是windows系统 。
        // 在生产环境Linux系统中，基本上都需要解任文件句柄数的限制，原因，Linux 系统的默认值是1024，也就是说，一个进程最多可以接受1024
        // 个socket连接，这是远远不够的。
        // 文件句柄，也叫文件描述符，在Linux 系统中，文件可分为，普通文件，目录文件，链接文件和设备文件，文件描述符（File Descriptor）
        // 是内核为了高效管理已经被打开的文件所创建的索引，它是一个非负整数（通常是小整数），用于指代被打开的文件，所有的IO系统调用
        // 包括socket的读写调用，都是通过文件描述符完成的。
        // 在Linux 下，通过调用ulimit命令，可以看到单个进程能够打印的最大文件句柄数量，这个命令的具体使用方法是：
        // ulimit -n
        // 什么是ulimit命令呢？ 它是用来显示和修改当前用户进程的一些基础限制的命令，-n 命令选项用于引用或设置当前的文件句柄数量的限制值
        // Linux 的系统默认值为1024
        // 默认的数值是1024，对绝大多数应用（例如 Apache , 桌面应用程序）来说已经足够了，但是，是对于一些用户期数很大的高并发应用，则
        // 是远远不够的，一个高并发的应用，面临的并发连接数往往是十万级，百万级，千万组，甚至像腾讯 QQ 一样的上亿级。
        // 文件句柄数不够，会导致什么样的后果呢？ 当单个进程打印的文件句柄数量，超过了系统配置的上限时，就会发出"socket/file:Can nto open so many files" 的错误提示
        // 对于 高并发，高负载的应用，就必须要调整这个系统参数，以适应处理并发处理大量连接的应用场景，可以通过ulimit来设置这两个参数，该当如下 ：
        // ulimit -n 10000
        // 在上面的命令中，n 的设置值越大， 可以打开的文件句柄数量就越大，建议使用root用户来执行些命令。
        // 如果想永久的把设置值保存下来， 可以编辑/etc/rc.local开机启动文件，在文件中添加如下内容：
        // ulimit -SHn 1000000
        // 增加-S和-H两个命令选项，选项-S表示软性极限值，-H 表示硬性极限值， 硬性极限的实际限制就是最大可以是100万，不能再多了。
        // 软性极限是系统警告Warning的超过这个极限值，内核会发出警告。
        // 普通用户通过ulimit命令，可以将软极限更改到硬极限的最大设置值，如果要更改硬极限，必须拥有root用户权限 。
        // 终极解除Linux 系统的最大文件打开数量的限制，可以通过编辑Linux 的极限配置文件/etc/security/limits.conf 来解决这些问题，修改文件，加入如下内容
        // soft nofile 100 0000
        // hard nofile 100 0000
        //




    }
}
